# Jolie2Java V2

Jolie2Java V2 is the evolution of the Jolie2Java tool, in some ways also being a successor to the JSDT tool, and is meant to provide a more idiomatic way to interact with Jolie types through Java.

The goal of the tool is to provide users with a way to define their APIs in Jolie but implement them in Java, to accomplish this the tool allows you to specify a Jolie file in order to generate:

- a class for every type defined in the given Jolie file,
- an interface for every interface defined in the given Jolie file,
- a class for every unique fault used in one of the interfaces, and
- (optionally) a class implementing each of the generated interfaces with a skeleton implementation of each method (API call).

## Quick Start

### Requirements

In order to use the classes generated by the tool you should be using Java 21, additionally the generated classes require the **jolie2java** module as a dependency atm, so make sure the **pom.xml** file of your project imports it and that the compiled files actually have access to them. (An example of a project using the new jolie2java tool can be found in the **/javaServices/newJavaServices** directory of the repository)

### Compilation

In order to ensure everything works correctly it is recommended to run the following command

    mvn clean install

in the main directory of the repository in order to ensure that not only jolie2java, but also all the modules that might be required by it, are installed and available. 

### Usage

In order to easily access the tool it is recommended to work in the devcontainer provided by the repository, from within which the tool can be used with the following command:

    jolie2java --packageName <package>
               [ --typesPackage <package> (default="types" ) ]
               [ --faultsPackage <package> (default="faults" ) ]
               [ --interfacesPackage <package> (default="interfaces" ) ]
               [ --outputDirectory <path> (default="./generated" ) ]
               [ --generateService <true|false> (default=true) ]
               [ --serviceName <name> (default="MainService") ] 
               <file>

where **file** should be either a .ol or .iol file. Alternatively, if you aren't using the devcontainer, you can access the tool by replacing **jolie2java** with the path to the appropriate executable in the **launchers** directory of the repository in the above example.


## Documentation

Jolie2Java consists of two parts, one is the tool itself, which takes a Jolie file and generates some classes, the other is a set of classes which are used by the generated classes. The following sections will focus on what is generated by the tool, and how the utility classes are used by the generated classes.

### Type Categories

In order to generate the classes for every type in a given Jolie file, Jolie2Java categorizes each type into one of the following:

- Undefined
- Native
- Custom
    - Basic
    - Structure
    - Choice

Note that aliases are categorized based on what they are an alias of, e.g. consider the following Jolie type:

    type Alias: T

here the category of `Alias` is exactly that of `T`.

#### Undefined

The Undefined category is exclusively used for the `undefined` type from Jolie (being a shorthand for `any {?}`).

#### Native

The Native category is used for all types native to Jolie, other than `undefined`, meaning `any` and every type which it is a choice of.

#### Basic

The Basic category is used for all custom types which are defined as a refinement of a type categorized as Native.

##### Examples

    type BasicType1: int( ranges( [1,5], [10,15] ) )
    type BasicType2: string( enum( ["hello", "world"] ) )
    type BasicType3: BasicType1

#### Structure

The Structure category is used for all custom types which are defined as some content type with children fields.

##### Examples

    type StructureType1: bool {?}
    type StructureType2: double { afield: raw, bfield: StructureType1 }
    type StructureType3: StructureType2

#### Choice

The Choice category is used for all custom types which are defined as a choice between two or more types.

##### Examples

    type ChoiceType1: int | bool
    type ChoiceType2: ChoiceType1 | StructureType2 | BasicType3 | void
    type ChoiceType3: ChoiceType2


### Type Hierarchy

In order to emulate the type hierarchy of Jolie, as well as ease the class generation process, Jolie2Java has a number of classes which aid in facilitating this, but we will focus on two of them.

#### JolieNative

`JolieNative` is the representation of the `any` type from Jolie, which can be described as follows:

```java
public sealed interface JolieNative<T> {

    T value();

    public static record JolieVoid() implements JolieNative<Void> {}
    public static record JolieBool( Boolean value ) implements JolieNative<Boolean> {}
    ...
    public static record JolieRaw( ByteArray value ) implements JolieNative<ByteArray> {}
}
```

The idea behind defining `any` like this in Java is that, is that you can leverage Java 21's enhanced switch expressions to retrieve the actual value, like shown below:

```java
public class MyService {
    public void myCall( JolieNative<?> request ) {
        switch ( request ) {
            case JolieNative.JolieBool( Boolean r ) -> {...}
            case JolieNative.JolieInt( Integer r ) -> {...}
            ...
            case JolieNative.JolieVoid() -> {...}
        }
    }
}
```

Note that while `any` is translated to `JolieNative`, other basic types are translated to their Java equivalents, so `bool` is translated to `Boolean`, `int` is translated to `Integer`, etc.

#### JolieValue

`JolieValue` is the representation of the `undefined` type from Jolie, which can be described as follows:

```java
public interface JolieValue {
    NativeType<?> content();
    Map<String, List<JolieValue>> children();
}
```

where `content()` returns the data stored directly by the type and `children()` returns a map of all the fields of the type. Note that all generated classes used to represent custom types inherit from `JolieValue`, so while the generated classes will provide better, type safe, ways of accessing its data, you can always use these methods, which can be relevant if e.g. a field has a name which conflicts with some reserved keyword (see the [Naming Conflicts](#naming-conflicts) section for more details).

#### Structural Equivalence

One aspect of JolieÂ´s type hierarchy which is difficult to emulate in Java is the fact that Jolie is Structurally typed, as opposed to Java which is nominally typed. While Java's inheritance system could be leveraged to attempt to somewhat emulate structural equivalence, instead every generated class contains a method, `createFrom( JolieValue t )`, which allows one to easily convert between structurally equivalent types.


### Class Generation

When the Jolie2Java tool is given a Jolie file it prompts the generation of a multitude of classes, this section will focus on what is generated based on the contents of the given file.

#### Type Classes

For every Jolie type categorized as Custom, a class will be generated in order to allow idiomatic interaction with that type in Java.

##### Basic Classes

As an example of a type categorized as Basic, let's consider the following Jolie type:

    type MyBasic: int( range( [1, 10] ) )

This type will prompt the generation of the following class:

```java
public record MyBasic( Integer contentValue ) implements JolieValue {

    ...

    public static MyBasic create( Integer v ) throws TypeValidationException {...}
    public static MyBasic createFrom( JolieValue t ) throws TypeValidationException {...}
}
```

##### Structure Classes

As an example of a type categorized as Structure, let's consider the following Jolie type:

    type MyStructure: string {
        .undefinedField: undefined
        .structureField: bool {?}
        .possibleChoice?: int | long
        .basicVector[2,3]: double( ranges( [0.0, 1.0] ) )
    }

This type will prompt the generation of the following class:

```java
public final class MyStructure extends ImmutableStructure<JolieString> {

    public JolieValue undefinedField() {...}
    public StructureField structureField() {...}
    public Optional<PossibleChoice> possibleChoice() {...}
    public List<Double> basicVector() {...}

    ...

    public static InlineBuilder construct() {...}
    public static InlineBuilder construct( JolieString content ) {...}
    public static InlineBuilder construct( String contentValue ) {...}

    ...

    public static InlineBuilder constructFrom( JolieValue t ) {...}

    public static MyStructure createFrom( JolieValue t ) throws TypeValidationException {...}

    ...

    static abstract class Builder<B> extends StructureBuilder<JolieString, B> {...}

    ...

    static abstract class ListBuilder<B> extends StructureListBuilder< MyStructure, B> {...}
    
    ...

    public static final class StructureField extends ImmutableStructure<JolieBool> {...}

    public static sealed interface PossibleChoice extends JolieValue {...}

    public static record BasicVector( Double contentValue ) implements JolieValue {...}
}
```

##### Choice Classes

As an example of a type categorized as Choice, let's consider the following Jolie type:

    type MyChoice: MyStructure | long | MyBasic | bool {?} | void

This type will prompt the generation of the following class:

```java
public sealed interface MyChoice extends JolieValue {

    public static record C1( MyStructure option ) implements MyChoice {
        ...

        public static class InlineBuilder extends MyStructure.Builder<InlineBuilder> {...}
    }

    public static record C2( Long option ) implements MyChoice {...}

    public static record C3( Integer option ) implements MyChoice {...}

    public static record C4( S1 option ) implements MyChoice {
        ...

        public static class InlineBuilder extends S1.Builder<InlineBuilder> {...}
    }

    public static record C5() implements MyChoice {...}

    ...

    public static MyChoice create1( MyStructure option ) {...}
    public static C1.InlineBuilder construct1() {...}
    public static C1.InlineBuilder construct1( JolieString content ) {...}
    public static C1.InlineBuilder construct1( String contentValue ) {...}
    public static C1.InlineBuilder construct1From( JolieValue t ) {...}

    public static MyChoice create2( Long option ) {...}

    public static MyChoice create3( Integer option ) throws TypeValidationException {...}

    public static MyChoice create4( MyChoice.S1 option ) {...}
    public static C4.InlineBuilder construct4() {...}
    public static C4.InlineBuilder construct4( JolieBool content ) {...}
    public static C4.InlineBuilder construct4( Boolean contentValue ) {...}
    public static C4.InlineBuilder construct4From( JolieValue t ) {...}

    public static MyChoice create5() {...}

    public static MyChoice createFrom( JolieValue t ) {...}

    ...

    static abstract class ListBuilder<B> extends StructureListBuilder< MyChoice, B> {...}
    
    ...

    public static final class S1 extends ImmutableStructure<JolieBool> {...}
}
```


#### Builder Classes

Builder classes are generated as inner classes of type classes, and are used to simplify the process of instantiating types which can have multiple fields with many different cardinalities. There are two main variations of Builder classes which can be included in a generated class, which will be discussed in the following sections.


##### Regular Builder Classes

For the regular builder classes, `StructureBuilder<R,B>` serves as the base, ensuring that every builder has methods to set any field, including, but not limited to, the following:

```java
public final B put( 
    String name, 
    SequencedCollection<? extends JolieValue> child 
) {...}

public final B compute( 
    String name, 
    BiFunction<
        ? super String, 
        ? super List<JolieValue>, 
        ? extends SequencedCollection<? extends JolieValue>
    > remappingFunction
) {...}
```

As for the actual generated builder classes, firstly an abstract class is generated, which, for the following structure type:

    type GenericStructure N { field[i,j]: T }

if we let `V` and `U` be some translation of `N` and `T` respectively, will have generated methods that can be categorized as one of the following:

- Setters, e.g. 

```java
    public B content( V content ) {...}
    public B setField( U child ) {...}
    public B setField( SequencedCollection<? extends U> child ) {...}
```

- Replacers, e.g.

```java
public U.NestedBuilder<B> reconstructField() {...}
public B replaceField( UnaryOperator<U> operator ) {...}
public U.NestedListBuilder<B> reconstructField() {...}
public B mergeField( SequencedCollection<U> values, BinaryOperator<SequencedCollection<U>> operator ) {...}
```

- Shortcuts (to the instantiation methods of a type), e.g. 

```java
public U.NestedBuilder<B> constructField() {...}
public U.NestedBuilder<B> constructFieldFrom( JolieValue t ) {...}
public U.NestedListBuilder<B> constructField() {...}
public U.NestedListBuilder<B> constructFieldFrom( SequencedCollection<? extends JolieValue> c ) {...}
```

As an example of what is generated, let's consider the following Jolie type:

    type OtherStructure: bool {
        .intField?: int
        .undefinedField: undefined
        .choiceField: MyStructure | raw | OtherStructure | void
        .anyVector[0,5]: any
        .nativeVector[3,5]: string
    }

This type will prompt the generation of the following inner builder classes:

```java
static abstract class Builder<B> extends StructureBuilder<JolieNative<?>, B> {
    
    ...

    public B content( Boolean value ) {...}
    public B content( UnaryOperator<Boolean> valueOperator ) {...}

    public B setIntField( JolieInt child ) {...}
    public B setIntField( Integer childValue ) {...}
    public B replaceIntField( UnaryOperator<Integer> valueOperator ) {...}

    public B setUndefinedField( JolieValue child ) {...}
    public JolieValue.NestedBuilder<B> constructUndefinedField() {...}
    public JolieValue.NestedBuilder<B> constructUndefinedField( JolieNative<?> content ) {...}
    public JolieValue.NestedBuilder<B> constructUndefinedField( Boolean contentValue ) {...}
    ...
    public JolieValue.NestedBuilder<B> constructUndefinedField( ByteArray contentValue ) {...}
    public JolieValue.NestedBuilder<B> constructUndefinedFieldFrom( JolieValue t ) {...}
    public JolieValue.NestedBuilder<B> reconstructUndefinedField() {...}
    public JolieValue.NestedBuilder<B> reconstructUndefinedField( UnaryOperator<JolieNative<?>> rootOperator ) {...}

    public B setChoiceField( ChoiceField child ) {...}

    public B setChoiceField1( MyStructure childOption ) {...}
    public MyStructure.NestedBuilder<B> constructChoiceField1() {...}
    public MyStructure.NestedBuilder<B> constructChoiceField1( JolieString content ) {...}
    public MyStructure.NestedBuilder<B> constructChoiceField1( String contentValue ) {...}
    public MyStructure.NestedBuilder<B> constructChoiceField1From( JolieValue t ) {...}
    public MyStructure.NestedBuilder<B> reconstructChoiceField1() {...}
    public MyStructure.NestedBuilder<B> reconstructChoiceField1( UnaryOperator<String> valueOperator ) {...}

    public B setChoiceField2( ByteArray childOption ) {...}

    public B setChoiceField3( OtherStructure childOption )
    public OtherStructure.NestedBuilder<B> constructChoiceField3() {...}
    public OtherStructure.NestedBuilder<B> constructChoiceField3( JolieBool content ) {...}
    public OtherStructure.NestedBuilder<B> constructChoiceField3( Boolean contentValue ) {...}
    public OtherStructure.NestedBuilder<B> constructChoiceField3From( JolieValue t ) {...}
    public OtherStructure.NestedBuilder<B> reconstructChoiceField3() {...}
    public OtherStructure.NestedBuilder<B> reconstructChoiceField3( UnaryOperator<Boolean> valueOperator ) {...}

    public B setChoiceField4() {...}

    public JolieNative.NestedListBuilder<B> constructAnyVector() {...}
    public JolieNative.NestedListBuilder<B> constructAnyVectorFrom( SequencedCollection<? extends JolieValue> c ) {...}
    public JolieNative.NestedListBuilder<B> reconstructAnyVector() {...}

    public B setNativeVector( SequencedCollection<String> values ) {...}
    public B setNativeVector( String... values ) {...}
    public B mergeNativeVector( SequencedCollection<String> values, BinaryOperator<SequencedCollection<String>> operator ) {...}
}

public static class InlineBuilder extends Builder<InlineBuilder> {
    ...

    public OtherStructure build() throws TypeValidationException {...}
}

public static class NestedBuilder<P> extends Builder<NestedBuilder<P>> {
    ...

    public P done() throws TypeValidationException {...}
}
```

Here `InlineBuilder` and `NestedBuilder<P>` are the concrete builders, used to build the outer class by the user and by other builders respectively.


##### List Builder Classes

For the list builder classes, `StructureListBuilder<T,B>` serves as the base, providing methods to manipulate the list of elements being build by some list builder, including, but not limited to, the following:

```java
public final B add( T e ) {...}
public final B addAll( SequencedCollection<? extends T> c ) {...}
public final B set( int index, T e ) {...}
public final B replace( int index, UnaryOperator<T> operator ) {...}
public final B remove( JolieValue e ) {...}
public final B removeIf( Predicate<? super T> filter ) {...}
```

As an example of the generated list builders, let's consider the following Jolie type:

    type OtherChoice: raw | bool {?} | void

This type will prompt the generation of the following inner list builder classes:

```java
static abstract class ListBuilder<B> extends StructureListBuilder<OtherChoice, B> {
    
    ...

    public B add1( ByteArray option ) {...}
    public B set1( int index, ByteArray option ) {...}

    public B add2( S1 option ) {...}
    public B set2( int index, S1 option ) {...}
    public S1.NestedBuilder<B> addConstructed2() {...}
    public S1.NestedBuilder<B> setConstructed2( int index ) {...}
    public S1.NestedBuilder<B> addConstructed2From( JolieValue t ) {...}
    public S1.NestedBuilder<B> setConstructed2From( int index, JolieValue t ) {...}
    public S1.NestedBuilder<B> reconstruct2( int index ) {...}
    public S1.NestedBuilder<B> addConstructed2( JolieBool content ) {...}
    public S1.NestedBuilder<B> setConstructed2( int index, JolieBool content ) {...}
    public S1.NestedBuilder<B> addConstructed2( Boolean contentValue ) {...}
    public S1.NestedBuilder<B> setConstructed2( int index, Boolean contentValue ) {...}
    public S1.NestedBuilder<B> reconstruct2( int index, UnaryOperator<Boolean> valueOperator ) {...}

    public B add3() {...}
    public B set3( int index ) {...}
}

public static class InlineListBuilder extends ListBuilder<InlineListBuilder> {
    ...

    public List<OtherChoice> build() throws TypeValidationException {...}
}

public static class NestedListBuilder<P> extends ListBuilder<NestedListBuilder<P>> {
    ...

    public P done() throws TypeValidationException {...}
}
```

The main distinction between list builders and regular builders is that regular builders are used to build the fields of a single instance of some class, whereas a list builder is used to build multiple instances of some class.


#### Fault Classes

In Jolie it is possible to define custom faults which can store any given Jolie type, in order to provide the ability to throw these faults from within a Java service Jolie2Java will generate a class for each fault used in some API declaration. As an example of what is generated consider the following Jolie API declaration:

    my_rr( undefined )( undefined ) throws MyFault( any )

this declaration will prompt the generation of the following class:

```java
public class MyFault extends FaultException {

    private final JolieNative<?> fault;

    public JolieNative<?> fault() {...}

    public MyFault( JolieNative<?> fault ) {...}
    public MyFault( Boolean faultValue ) {...}
    ...
    public MyFault( ByteArray faultValue ) {...}
    public MyFault() {...}
}
```

Faults which contain a custom type will have additional ways of more conveniently instatiating the fault with that type, as an example let's consider the following Jolie API declaration:

    other_rr( undefined )( undefined ) throws OtherFault( OtherChoice )

```java
public class OtherFault extends FaultException {

    private final OtherChoice fault;

    public OtherChoice fault() {...}

    public OtherFault( OtherChoice fault ) {...}
    public OtherFault( ByteArray faultOption ) {...}
    public OtherFault( OtherChoice.S1 faultOption ) {...}
    public OtherFault() {...}

    public static OtherFault create1( Function<OtherChoice.S1.InlineBuilder, OtherChoice.S1> builder ) {...}
    public static OtherFault create1From( JolieValue t, Function<OtherChoice.S1.InlineBuilder, OtherChoice.S1> rebuilder ) {...}
}
```

#### Interface Classes

In Jolie it's possible to define an interface, containing some number of API declarations, for each such interface declared in a given Jolie file, Jolie2Java will generate an interface class containing Java equivalents to each API declaration. As an example of what gets generated let's conider the following Jolie Interface:

    interface MyInterface {
        OneWay:
            my_ow1( bool ),
            my_ow2( undefined )

        RequestResponse:
            my_rr1( any )( SomeStructure ),
            my_rr2( SomeChoice )( raw ) throws SomeFault,
            
            /**!
             * some documentation
             */
            my_rr3( void )( someBasic )
    }

this interface will prompt the generation of the following class:

```java
public interface MyInterface {

    void my_ow1( Boolean request ) throws FaultException;
    
    void my_ow2( JolieValue request ) throws FaultException;
    
    SomeStructure my_rr1( JolieNative<?> request ) throws FaultException;
    
    ByteArray my_rr2( SomeChoice request ) throws FaultException;
    
    /**
     * some documentation
     */
    SomeBasic my_rr3() throws FaultException;
}
```

#### Service Classes

Jolie2Java allows the user to set a flag in order to have a service class generated, along with an option to choose its name, which implements every generated interface and contains empty implementations of every method. As an example of what is generated, let's consider `MyInterface` from the previous section, for which the following class is generated:

```java
public final class GeneratedService extends JavaService implements MyInterface {

    public void my_ow1( Boolean request ) {
        /* developer code */
    }

    public void my_ow2( JolieValue request ) {
        /* developer code */
    }

    public SomeStructure my_rr1( JolieNative<?> request ) {
        switch ( request ) {
            case JolieNative.JolieVoid() -> {}
            case JolieNative.JolieBool( Boolean r ) -> {}
            ...
            case JolieNative.JolieRaw( ByteArray r ) -> {}
        }

        return SomeStructure.construct()
            /* fields */
            .build();
    }

    public ByteArray my_rr2( SomeChoice request ) throws SomeFault {
        switch ( request ) {
            case SomeChoice.C1( T1 option ) -> {}
            ...
            case SomeChoice.Cn( Tn option ) -> {}
        }

        return null; /* TODO: replace with actual value */
    }

    public SomeBasic my_rr3() {
        return SomeBasic.create( null ) /* TODO: replace with actual value */
    }
}
```

### Naming Conflicts

When we create Java classes based on Jolie definitions, in order to keep them idiomatic while staying true to their Jolie counterparts, naming conflicts are inevitably going to be a problem.

#### Field Names

Whenever we have a Structure type with named fields, we want to generate getters and setters in order to make their data easily accessible. In particular, in order to be as idiomatic as possible, for a Jolie type like the following:

    type MyType: void {
        aField: int
        bField: long
    }

we would like to generate the following getters:

```java
public Integer aField() {...}
public Long bField() {...}
```

In order to determine the name to be used for the methods of a field, we use the following strategy:

1. Remove all invalid characters from each field's name (being every character matching the regex `\W`)
2. If the name of a field is reserved, remove its name.
3. Group all fields together based on their name.
4. If any group from (3.) has more than one field in it, remove the name of every field in that group which name changed during (1.).

Step (1) is done because Jolie allows arbitrary strings to be used as the name of a field, so we have to remove characters which can't be used in the name of a method from it.

Step (2) is done because Java has reserved keywords, e.g. `public`, which can't be used as the name of a method, and because Jolie2Java generates certain methods, e.g. `content()`, which also can result in conflicts.

Step (3-4) is done in order to prevent fields which end up with the same name after step (1) from conflicting with one another.

For any field which has its name removed, no dedicated getter or setters will be generated, and it will instead be necessary to use the non-typesafe getters and setters to interact with the data of that field.

#### Type Names

Currently, whenever a Jolie type categorized as Custom is to be translated into a Java class, we use the following strategy to determine the name of the class:

1. Let `N` be the capitalization of the name given to the Jolie type.
2. If `N` conflicts with any other type name used, add the prefix `Custom` to it and return that.
3. If `N` consists of a single letter followed by 0 or more numbers, add the postfix `Type` to it and return it.
4. Return `N`.

Step (1.) is done both because its more idiomatic to have Java class names be capitalized, and because it removes a lot of potential naming conflicts with reserved keywords in Java (e.g. `public` or `static`).

Step (2.) is done because, compared to in Jolie where you only have to worry about naming conflicts with other types, in Java we have to ensure the name of a generated class doesn't conflict with any of the classes that are used as part of its implementation.

Step (3.) is done to prevent potential conflicts with type parameters as well as with the inner classes generated as part of the implementation of choice types.

This strategy is obviously very exploitable, but the point isn't to prevent the a malicious developer from creating types which lead to conflicting names, since that only really affects themselves, but to increase the likelyhood of a reasonable set of Jolie types to result in a set of usable Java classes being generated.

The following subsections will look at examples of valid Jolie types which can result in the generated classes being incorrect.

##### Overlapping Class Names

The Jolie types:

    type JolieValue: double {?}
    type CustomJolieValue: long {?}
    type customJolieValue: int {?}

all get translated to `CustomJolieValue`, so one always overwrites the others.

##### Inner Class Hiding Enclosing Class

The Jolie type:

    type MyType: int { myType: long { myType: double } }

gets translated to:

```java
public final class MyType ... {
    ...

    public static final class MyType ... {
        ...

        public static final class MyType ... {...}
    }
}
```

where each inner `MyType` class is hiding the enclosing `MyType` class.

##### Inner Class Hiding Other Class

The Jolie types:

    type MyType: void {?}
    type OtherType: int { myType: bool { field: MyType } }

gets translated to:

```java
public final class MyType ... {...}

public final class OtherType ... {
    ...

    public static final class MyType {

        public MyType field() {...}
        
        ...
    }
}
```

where the type returned by `field()` is `OtherType.MyType` rather than `MyType`.

#### Fault Names

In Jolie it's entirely valid to declare an API like the following:

    my_rr( undefined )( undefined ) 
        throws  MyFault( int ) 
                MyFault( long ) 
                MyFault( SomeType )

Which is handled by, whenever faults with matching names but distinct types are detected, appending the name of the type to the name of the fault, so the given declaration would prompt the generation of the classes:

```java
public class MyFaultInt extends FaultException {...}
public class MyFaultLong extends FaultException {...}
public class MyFaultSomeType extends FaultException {...}
```

Ensuring that there are no conflicts with the new names and any other faults however is not supported, and is left up to the developer, as an example if we changed the previous API to instead be the following:

    my_rr( undefined )( undefined ) 
        throws  MyFault( int ) 
                MyFault( long ) 
                MyFaultInt( SomeType )

Then we would generate the classes:

```java
public class MyFaultInt extends FaultException {...}
public class MyFaultLong extends FaultException {...}
public class MyFaultInt extends FaultException {...}
```

thus getting a naming conflict.
