# Jolie2Java V2

Jolie2Java V2 is the evolution of the Jolie2Java tool, in some ways also being a successor to the JSDT tool, and is meant to provide a more idiomatic way to interact with Jolie types through Java.

The goal of the tool is to provide users with a way to define their APIs in Jolie but implement them in Java, to accomplish this the tool allows you to specify a Jolie file in order to generate:

- a class for every type defined in the given Jolie file,
- an interface for every interface defined in the given Jolie file,
- a class for every unique fault used in one of the interfaces, and
- (optionally) a class implementing each of the generated interfaces with a skeleton implementation of each method (API call).

## Quick Start

### Requirements

In order to use the classes generated by the tool you should be using Java 21, additionally the generated classes require the **jolie** module as a dependency, so make sure the **pom.xml** file of your project imports it and that the compiled files actually have access to it. (An example of a project using the new jolie2java tool can be found in the **/javaServices/newJavaServices** directory of the repository)

### Compilation

In order to ensure everything works correctly it is recommended to run the following command

    mvn clean install

in the main directory of the repository in order to ensure that not only jolie2java, but also all the modules that might be required by it, are installed and available. 

### Usage

In order to easily access the tool it is recommended to work in the devcontainer provided by the repository, from within which the tool can be used with the following command:

    jolie2java --packageName <package>
               [ --typesPackage <package> (default=".types" ) ]
               [ --faultsPackage <package> (default=".faults" ) ]
               [ --interfacesPackage <package> (default=".interfaces" ) ]
               [ --outputDirectory <path> (default="./generated" ) ]
               [ --generateService <true|false> (default=true) ]
               [ --serviceName <name> (default="MainService") ] 
               <file>

where **file** should be either a .ol or .iol file. Alternatively, if you aren't using the devcontainer, you can access the tool by replacing **jolie2java** with the path to the appropriate executable in the **launchers** directory of the repository in the above example.


## Documentation

Jolie2Java consists of two parts, one is the tool itself, which takes a Jolie file and generates some classes, the other is a set of classes which are used by the generated classes. The following sections will focus on what is generated by the tool, and how the utility classes are used by the generated classes.

### Type Categories

In order to generate the classes for every type in a given Jolie file, Jolie2Java categorizes each type into one of the following:

- Undefined
- Native
- Custom
    - Basic
    - Structure
        - Untyped
        - Typed
    - Choice

Note that aliases are categorized based on what they are an alias of, e.g. consider the following Jolie type:

    type Alias: T

here the category of `Alias` is exactly that of `T`.

#### Undefined

The Undefined category is exclusively used for the `undefined` type from Jolie (being a shorthand for `any {?}`).

#### Native

The Native category is used for all types native to Jolie, other than `undefined`, meaning `any` and every type which it is a choice of.

#### Basic

The Basic category is used for all custom types which are defined as a refinement of a type categorized as Native.

##### Examples

    type BasicType1: int( ranges( [1,5], [10,15] ) )
    type BasicType2: string( enum( ["hello", "world"] ) )
    type BasicType3: BasicType1

#### Untyped Structure

The Untyped Structure category is used for all custom types which are defined as some content type with untyped children.

##### Examples

    type UntypedStructure1: bool {?}
    type UntypedStructure2: void {?}
    type UntypedStructure3: UntypedStructure2

#### Typed Structure

The Typed Structure category is used for all custom types which are defined as some content type with children fields.

##### Examples

    type TypedStructure1: bool { field: undefined }
    type TypedStructure2: double { afield: raw, bfield: TypedStructure1 }
    type TypedStructure3: TypedStructure2

#### Choice

The Choice category is used for all custom types which are defined as a choice between two or more types.

##### Examples

    type ChoiceType1: int | bool
    type ChoiceType2: ChoiceType1 | StructureType2 | BasicType3 | void
    type ChoiceType3: ChoiceType2


### Type Hierarchy

In order to emulate the type hierarchy of Jolie, as well as ease the class generation process, Jolie2Java has a number of classes which aid in facilitating this, but we will focus on two of them.

#### JolieNative

`JolieNative` is the representation of the `any` type from Jolie, which can be described as follows:

```java
public sealed interface JolieNative<T> {

    T value();

    public static record JolieVoid() implements JolieNative<Void> {}
    public static record JolieBool( Boolean value ) implements JolieNative<Boolean> {}
    ...
    public static record JolieRaw( ByteArray value ) implements JolieNative<ByteArray> {}
}
```

The idea behind defining `any` like this in Java is that, is that you can leverage Java 21's enhanced switch expressions to retrieve the actual value, like shown below:

```java
public class MyService {
    public void myCall( JolieNative<?> request ) {
        switch ( request ) {
            case JolieBool( Boolean r ) -> {...}
            case JolieInt( Integer r ) -> {...}
            ...
            case JolieVoid() -> {...}
        }
    }
}
```

Note that while `any` is translated to `JolieNative`, other basic types are translated to their Java equivalents, so `bool` is translated to `Boolean`, `int` is translated to `Integer`, etc.

#### JolieValue

`JolieValue` is the representation of the `undefined` type from Jolie, which can be described as follows:

```java
public interface JolieValue {
    NativeType<?> content();
    Map<String, List<JolieValue>> children();
}
```

where `content()` returns the data stored directly by the type and `children()` returns a map of all the fields of the type. Note that all generated classes used to represent custom types inherit from `JolieValue`, so while the generated classes will provide better, type safe, ways of accessing its data, you can always use these methods, which can be relevant if e.g. a field has a name which conflicts with some reserved keyword (see the [Naming Conflicts](#naming-conflicts) section for more details).

#### Structural Equivalence

One aspect of JolieÂ´s type hierarchy which is difficult to emulate in Java is the fact that Jolie is Structurally typed, as opposed to Java which is nominally typed. While Java's inheritance system could be leveraged to attempt to somewhat emulate structural equivalence, instead every generated class contains a method, `createFrom( JolieValue t )`, which allows one to easily convert between structurally equivalent types.


### Class Generation

When the Jolie2Java tool is given a Jolie file it prompts the generation of a multitude of classes, this section will focus on what is generated based on the contents of the given file.

#### Type Classes

For every Jolie type categorized as Custom, a class will be generated in order to allow idiomatic interaction with that type in Java.

##### Basic Classes

As an example of a type categorized as Basic, let's consider the following Jolie type:

    type MyBasic: int( range( [1, 10] ) )

This type will prompt the generation of the following class:

```java
public record MyBasic( Integer contentValue ) implements JolieValue {...}
```

##### Untyped Structure Classes

As an example of a type categorized as an Untyped Structure, let's consider the following Jolie type:

    type MyUntypedStructure: int {?}

This type will prompt the generation of the following class:

```java
public final class MyUntypedStructure extends ImmutableStructure<JolieInt> {...}
```

##### Typed Structure Classes

As an example of a type categorized as Structure, let's consider the following Jolie type:

    type MyStructure: string {
        .undefinedField: undefined
        .untypedField: bool {?}
        .possibleChoice?: int | long
        .basicVector[2,3]: double( ranges( [0.0, 1.0] ) )
    }

This type will prompt the generation of the following class:

```java
public final class MyStructure implements JolieValue {

    ...

    public MyStructure( String contentValue, JolieValue undefinedField, ... ) {...}

    public String contentValue() {...}
    public JolieValue undefinedField() {...}
    public UntypedField untypedField() {...}
    public Optional<PossibleChoice> possibleChoice() {...}
    public List<Double> basicVector() {...}

    ...

    public static Builder construct() {...}
    public static Builder construct( String contentValue ) {...}
    public static Builder constructFrom( JolieValue t ) {...}

    public static MyStructure createFrom( JolieValue t ) throws TypeValidationException {...}

    ...

    public static class Builder {...}

    ...

    public static class ListBuilder extends AbstractListBuilder<MyStructure> {...}
    
    ...

    public static final class UntypedField extends ImmutableStructure<JolieBool> {...}

    public static sealed interface PossibleChoice extends JolieValue {...}

    public static record BasicVector( Double contentValue ) implements JolieValue {...}
}
```

##### Choice Classes

As an example of a type categorized as Choice, let's consider the following Jolie type:

    type MyChoice: MyStructure | long | MyBasic | bool {?} | void

This type will prompt the generation of the following class:

```java
public sealed interface MyChoice extends JolieValue {

    public static record C1( MyStructure option ) implements MyChoice {...}

    public static record C2( Long option ) implements MyChoice {...}

    public static record C3( Integer option ) implements MyChoice {...}

    public static record C4( S1 option ) implements MyChoice {...}

    public static record C5() implements MyChoice {...}

    ...

    public static MyChoice create1( MyStructure option ) {...}
    public static MyChoice create1( Function<MyStructure.Builder, MyStructure> b ) {...}

    public static MyChoice create2( Long option ) {...}

    public static MyChoice create3( Integer option ) throws TypeValidationException {...}

    public static MyChoice create4( S1 option ) {...}
    public static MyChoice create4( Function<S1.Builder, MyStructure> b ) {...}

    public static MyChoice create5() {...}

    public static MyChoice createFrom( JolieValue t ) {...}

    ...

    public static class ListBuilder extends AbstractListBuilder<MyChoice> {...}
    
    ...

    public static final class S1 extends ImmutableStructure<JolieBool> {...}
}
```


#### Builder Classes

Builder classes are generated as inner classes of type classes, and are used to simplify the process of instantiating types which can have multiple fields with many different cardinalities. There are two types of builders that can be generated for a class, regular Builder classes and ListBuilder classes, to understand how they work and differ from one another, let's consider the following Jolie type:

    type BuildableStructure: string {
        .choiceVector*: MyChoice
        .structureField: MyStructure
        .untypedVector[1,3]: int {?}
        .basicField?: double( ranges( [0.0, 1.0] ) )
    }

this will prompt the generation of the following classes being generated:

```java
public final class BuildableStructure implements JolieValue {
    ...

    public static class Builder {
        ...

        public Builder choiceVector( List<MyChoice> choiceVector ) {...}
        public Builder choiceVector( Function<MyChoice.ListBuilder, List<MyChoice>> b ) {...}

        public Builder structureField( List<MyStructure> structureField ) {...}
        public Builder structureField( Function<MyStructure.Builder, MyStructure> b ) {...}

        public Builder untypedVector( List<UntypedVector> untypedVector ) {...}
        public Builder untypedVector( Function<UntypedVector.ListBuilder, List<UntypedVector>> b ) {...}

        public Builder basicField( Boolean basicField ) {...}

        public BuildableStructure build() {...}
    }

    public static class ListBuilder extends AbstractListBuilder<ListBuilder, BuildableStructure> {
        ...

        public ListBuilder add( Function<Builder, BuildableStructure> b ) {...}
        public ListBuilder set( int index, Function<Builder, BuildableStructure> b ) {...}
        public ListBuilder reconstruct( int index, Function<Builder, BuildableStructure> b ) {...}
    }
    ...
}
```

As can be seen, the `Builder` class is useful for instantiating instances of the given class, whereas the `ListBuilder` is used by other `Builder` classes to more easily instantiate multiple instances of a given class.

Note that the `AbstractListBuilder<T>` class which the `ListBuilder` class inherits from is simply a convenience class to make generating these classes easier while giving them access to bunch of common convenience methods, including, but not limited to, the following:

```java
public abstract class AbstractListBuilder<B,E> {
    ...
    public final B add( E e ) {...}
    ...
    public final B addAll( SequencedCollection<? extends E> c ) {...}
    ...
    public final B set( int index, E e ) {...}
    ...
    public final B removeIf( Predicate<? super E> filter ) {...}
    ...
    public final List<E> build() {...}
}
```


#### Fault Classes

In Jolie it is possible to define custom faults which can store any given Jolie type, in order to provide the ability to throw these faults from within a Java service Jolie2Java will generate a class for each fault used in some API declaration. As an example of what is generated consider the following Jolie API declaration:

    my_rr( undefined )( undefined ) throws MyFault( any )

this declaration will prompt the generation of the following class:

```java
public class MyFault extends FaultException {

    private final JolieNative<?> fault;

    public MyFault( JolieNative<?> fault ) {...}

    public JolieNative<?> fault() {...}
}
```

#### Interface Classes

In Jolie it's possible to define an interface, containing some number of API declarations, for each such interface declared in a given Jolie file, Jolie2Java will generate an interface class containing Java equivalents to each API declaration. As an example of what gets generated let's conider the following Jolie Interface:

    interface MyInterface {
        OneWay:
            my_ow1( bool ),
            my_ow2( undefined )

        RequestResponse:
            my_rr1( any )( SomeStructure ),
            my_rr2( SomeChoice )( raw ) throws SomeFault,
            
            /**!
             * some documentation
             */
            my_rr3( void )( someBasic )
    }

this interface will prompt the generation of the following class:

```java
public interface MyInterface {

    void my_ow1( Boolean request ) throws FaultException;
    
    void my_ow2( JolieValue request ) throws FaultException;
    
    SomeStructure my_rr1( JolieNative<?> request ) throws FaultException;
    
    ByteArray my_rr2( SomeChoice request ) throws FaultException;
    
    /**
     * some documentation
     */
    SomeBasic my_rr3() throws FaultException;
}
```

#### Service Classes

Jolie2Java allows the user to set a flag in order to have a service class generated, along with an option to choose its name, which implements every generated interface and contains empty implementations of every method. As an example of what is generated, let's consider `MyInterface` from the previous section, for which the following class is generated:

```java
public final class GeneratedService extends JavaService implements MyInterface {

    public void my_ow1( Boolean request ) {
        /* developer code */
    }

    public void my_ow2( JolieValue request ) {
        /* developer code */
    }

    public SomeStructure my_rr1( JolieNative<?> request ) {
        switch ( request ) {
            case JolieVoid() -> {}
            case JolieBool( Boolean r ) -> {}
            ...
            case JolieRaw( ByteArray r ) -> {}
        }

        return SomeStructure.construct()
            /* fields */
            .build();
    }

    public ByteArray my_rr2( SomeChoice request ) throws SomeFault {
        switch ( request ) {
            case SomeChoice.C1( T1 option ) -> {}
            ...
            case SomeChoice.Cn( Tn option ) -> {}
        }

        return null; /* TODO: replace with actual value */
    }

    public SomeBasic my_rr3() {
        return SomeBasic.create( null ) /* TODO: replace with actual value */
    }
}
```

### Annotations

In order to increase the usability of the tool, jolie2java is able to recognize certain annotations made to the type definitions in Jolie, the currently supported annotations being:

#### @JavaName("NAME")

This annotation is used to specify a different name to be used in Java, primarily used to avoid naming conflicts that might arise from the difference in what is allowed as field names in Jolie and Java respectively.

##### Usage Example

```jolie
///@JavaName("MyStructure")
type myStructure: void {
    .char*: string //<@JavaName("chars")
    .c: int | long //<@JavaName("cfield")
    .field: void { 
        .field: int {?} //<@JavaName("innerField")
    }
}
```

The purpose of the annotations, in order of appearance, are:

1. jolie2java doesn't allow type names to be uncapitalized.
2. "char" is a reserved keyword in Java, so we can't use it as the name of a field.
3. jolie2java doesn't allow fields which type require them to generate an inner class, being all custom types except Basic ones, to have a name which consists of a single character.
4. Java doesn't allow inner classes to hide their enclosing classes.

#### @GenerateBuilder(true|false)

This annotation, which by default is set to `true`, is used to specify whether the generated class for a given type should include Builder classes, which is currently only generated for Structure and Choice types. The main purpose of this is to decrease generation time and memory consumption of the generated classes, by allowing one to not generate these extra classes if they aren't being used.

#### @InlineLink(true|false)

This annotation, which by default is set to `false`, is used to specify whether a given link to a type should be treated as if it had been defined as an inline type, primarily used to avoid generating additional classes for aliases or to ease data access in Structure fields.

##### Usage Example

```jolie
type MyBasic: int( ranges( [1,10] ) )

///@InlineLink(true)
type MyAlias: MyBasic

type MyStructure: void { 
    .field: MyBasic //<@InlineLink(true)
}
```

The purpose of the annotations, in order of appearance, are:

1. In order to not generate a `MyAlias` class, instead every appearance of this type is treated as if it was `MyBasic` instead by jolie2java.
2. In order to have `field` be of type `Integer`, rather than `MyBasic`, meaning you don't have to create an instance of `MyBasic` in order to be allowed to store it in `MyStructure`.

Note that if you were to do the following:

```jolie
type OtherStructure: void { 
    .field: MyStructure //<@InlineLink(true)
}
```

then it will result in the class for `OtherStructure` generating an inner class, `Field`, which is equivalent to the `MyStructure` class.

### Naming Conflicts

Jolie provides a lot of freedom when it comes to naming types and fields, with fields allowing you to use arbitrary strings, Java on the other hand is not as lenient, so in order to avoid conflicts jolie2java imposes the following rules:

1. Type names have to match the regex "[A-Z]\w[\w\d]\*"
2. Type names cannot match the name of any of the classes used by the generated files, including, but not limited to, `JolieValue`, `JolieNative`, `Boolean`, `Optional`, etc.
3. Field names have to match the regex "[a-z][\w\d]\*".
4. Field names cannot match any of method names reserved by jolie2java, including `content`, `contentValue`, `children`, `construct`, and `constructList`. Additionally they cannot match any of the reserved keywords from Java, including, but not limited to, `char`, `int`, `class`, etc.
5. When a field is defined as an inline Custom type, the capitalization of its name must adhere to (1.) and (2.) as well.

Breaking any of the above rules will result in the generation process failing, requiring you to either change the names directly or use the `@JavaName` annotation discussed previously.

There are certain types of naming conflicts which currently aren't being enforced, and therefore can result in the generated files being unable to compile, those being discussed in the following subsections.

#### Inner Class Hiding Enclosing Class

The Jolie type:

    type MyType: int { myType: long { myType: double } }

gets translated to:

```java
public final class MyType ... {
    ...

    public static final class MyType ... {
        ...

        public static final class MyType ... {...}
    }
}
```

where each inner `MyType` class is hiding the enclosing `MyType` class.

##### Inner Class Hiding Other Class

The Jolie types:

    type MyType: void {?}
    type OtherType: int { myType: bool { field: MyType } }

gets translated to:

```java
public final class MyType ... {...}

public final class OtherType ... {
    ...

    public static final class MyType {

        public MyType field() {...}
        
        ...
    }
}
```

where the type returned by `field()` is `OtherType.MyType` rather than `MyType`.

#### Fault Names

In Jolie it's entirely valid to declare an API like the following:

    my_rr( undefined )( undefined ) 
        throws  MyFault( int ) 
                MyFault( long ) 
                MyFault( SomeType )

Which is handled by, whenever faults with matching names but distinct types are detected, appending the name of the type to the name of the fault, so the given declaration would prompt the generation of the classes:

```java
public class MyFaultInt extends FaultException {...}
public class MyFaultLong extends FaultException {...}
public class MyFaultSomeType extends FaultException {...}
```

Ensuring that there are no conflicts with the new names and any other faults however is not supported, and is left up to the developer, as an example if we changed the previous API to instead be the following:

    my_rr( undefined )( undefined ) 
        throws  MyFault( int ) 
                MyFault( long ) 
                MyFaultInt( SomeType )

Then we would generate the classes:

```java
public class MyFaultInt extends FaultException {...}
public class MyFaultLong extends FaultException {...}
public class MyFaultInt extends FaultException {...}
```

thus getting a naming conflict.
